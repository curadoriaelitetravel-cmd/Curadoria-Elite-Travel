<script>
  /* =========================
     DADOS DO SUPABASE (materiais ativos + compras do usuário)
  ========================= */
  const materiaisAtivosPorCategoria = new Map();
  const ownedMap = new Map();

  function setAdminStatus(text, ok){
    const el = document.getElementById("admin-status");
    if (!el) return;
    el.innerText = text;
    el.classList.remove("ok","muted");
    el.classList.add(ok ? "ok" : "muted");
  }

  async function loadActiveMaterials(){
    materiaisAtivosPorCategoria.clear();

    try{
      ensureSupabase();

      const { data, error } = await supabaseClient
        .from("curadoria_materials")
        .select("category, city_label, pdf_url")
        .eq("is_active", true)
        .order("city_label", { ascending: true });

      if (error){
        setAdminStatus("Admin: erro ao carregar", false);
        return;
      }

      (data || []).forEach(row => {
        const cat = String(row.category || "").trim();
        const city = String(row.city_label || "").trim();
        const url = row.pdf_url || null;

        if (!cat || !city || !url) return;

        if (!materiaisAtivosPorCategoria.has(cat)) materiaisAtivosPorCategoria.set(cat, []);
        materiaisAtivosPorCategoria.get(cat).push({ cidade: city, pdf_url: url });
      });

      setAdminStatus("Admin: conectado", true);
    }catch(e){
      setAdminStatus("Admin: falha na conexão", false);
    }
  }

  async function loadOwnedPurchases(){
    ownedMap.clear();

    try{
      const sess = await getSession();
      if (!sess || !sess.user) return;

      ensureSupabase();

      const { data, error } = await supabaseClient
        .from("purchase")
        .select("category, city, pdf_url")
        .eq("user_id", sess.user.id)
        .limit(500);

      if (error) return;

      (data || []).forEach(row => {
        const k = purchaseKey(row.category || "", row.city || "");
        ownedMap.set(k, { pdf_url: row.pdf_url || null });
      });
    }catch(e){}
  }

  function userOwns(category, cityLabel){
    return ownedMap.has(purchaseKey(category, cityLabel));
  }

  /* =========================
     Regra: zerar carrinho após compra concluída
     - Se existe um "cart checkout" salvo e agora o usuário já possui todos aqueles itens,
       limpamos o carrinho e limpamos a marca do checkout.
  ========================= */
  function readCartCheckoutItems(){
    try{
      const raw = localStorage.getItem(CART_CHECKOUT_ITEMS_KEY);
      const parsed = raw ? JSON.parse(raw) : null;
      return Array.isArray(parsed) ? parsed : null;
    }catch(e){
      return null;
    }
  }

  function clearCartCheckoutMarker(){
    try{ localStorage.removeItem(CART_CHECKOUT_ITEMS_KEY); }catch(e){}
    try{ localStorage.removeItem(CART_LAST_CHECKOUT_STARTED_KEY); }catch(e){}
  }

  function cartCheckoutAllOwned(){
    const payload = readCartCheckoutItems();
    if (!payload || !payload.length) return false;
    return payload.every(it => it && userOwns(it.category, it.city));
  }

  function pruneCartOwnedItems(){
    const items = getCart();
    if (!items.length) return;

    const filtered = items.filter(it => it && !userOwns(it.category, it.city));
    if (filtered.length !== items.length){
      saveCart(filtered);
    }
  }

  async function handleCartAfterPurchaseIfNeeded(){
    const sess = await getSession();
    if (!sess || !sess.user) return;

    await loadOwnedPurchases();

    /* remove do carrinho o que já foi comprado */
    pruneCartOwnedItems();

    /* se foi checkout por carrinho e tudo já está comprado -> zera carrinho e limpa marcador */
    if (cartCheckoutAllOwned()){
      clearCart();
      clearCartCheckoutMarker();
      updateCartBadge();
    }else{
      /* se o marcador existir mas ainda não está tudo comprado, mantemos para não atrapalhar */
      updateCartBadge();
    }
  }

  /* =========================
     CURADORIA PANEL + cards
  ========================= */
  const BATCH_SIZE = 12;
  let currentCategory = null;
  let filteredCities = [];
  let visibleCount = 0;

  function normalizeText(str){
    return normalizeKeyPart(str || "");
  }

  function openCategory(category){
    currentCategory = category;

    const panel = document.getElementById("curadoria-panel");
    if (!panel) return;
    panel.style.display = "block";

    const bc = document.getElementById("breadcrumb");
    const pt = document.getElementById("panel-title");
    if (bc) bc.innerText = "Curadoria > " + category;
    if (pt) pt.innerText = category;

    const input = document.getElementById("city-search");
    if (input) input.value = "";

    const list = materiaisAtivosPorCategoria.get(category) || [];
    filteredCities = list.slice();
    visibleCount = Math.min(BATCH_SIZE, filteredCities.length);

    renderCities();

    setTimeout(() => {
      panel.scrollIntoView({ behavior: "smooth", block: "start" });
      if (input) input.focus({ preventScroll: true });
    }, 120);
  }

  function closeCategory(){
    const panel = document.getElementById("curadoria-panel");
    if (panel) panel.style.display = "none";
    currentCategory = null;
    filteredCities = [];
    visibleCount = 0;

    const cats = document.getElementById("curadoria-categories");
    if (cats) cats.scrollIntoView({ behavior: "smooth", block: "start" });
  }

  function onSearchCity(){
    if (!currentCategory) return;

    const input = document.getElementById("city-search");
    const q = normalizeText(input ? input.value : "");
    const all = (materiaisAtivosPorCategoria.get(currentCategory) || []);

    if (!q) filteredCities = all.slice();
    else filteredCities = all.filter(item => normalizeText(item.cidade).includes(q));

    visibleCount = Math.min(BATCH_SIZE, filteredCities.length);
    renderCities();
  }

  function loadMoreCities(){
    visibleCount = Math.min(visibleCount + BATCH_SIZE, filteredCities.length);
    renderCities(true);
  }

  function cartItemKey(category, cityLabel){
    return purchaseKey(category, cityLabel);
  }

  function addToCart(category, cityLabel){
    /* impedir adicionar se já possui */
    if (userOwns(category, cityLabel)){
      openPopup({
        title: "Carrinho",
        text: "Você já possui este produto. Ele já está disponível em Minha conta.",
        showProsseguir: false,
        showRules: false
      });
      updateCartBadge();
      return;
    }

    const items = getCart();
    const k = cartItemKey(category, cityLabel);

    if (items.some(it => it && it.key === k)){
      openPopup({
        title: "Carrinho",
        text: "Este material já está no carrinho.",
        showProsseguir: false,
        showRules: false
      });
      updateCartBadge();
      return;
    }

    const price = getPriceForCategory(category);

    items.push({
      key: k,
      category: String(category || "").trim(),
      city: String(cityLabel || "").trim(),
      qty: 1,
      price: Number(price || 0)
    });

    saveCart(items);
    updateCartBadge();
  }

  function renderCities(){
    const grid = document.getElementById("cities-grid");
    const empty = document.getElementById("empty-state");
    const btnMore = document.getElementById("btn-more");
    const citiesCount = document.getElementById("cities-count");
    const visible = document.getElementById("visible-count");

    if (!grid) return;

    const total = filteredCities.length;

    if (citiesCount) citiesCount.innerText = total + (total === 1 ? " cidade" : " cidades");
    if (visible) visible.innerText = "Mostrando " + Math.min(visibleCount, total);

    if (total === 0){
      grid.innerHTML = "";
      if (empty) empty.style.display = "block";
      if (btnMore) btnMore.style.display = "none";
      return;
    }

    if (empty) empty.style.display = "none";

    const slice = filteredCities.slice(0, visibleCount);
    grid.innerHTML = "";

    slice.forEach((item) => {
      const div = document.createElement("div");
      div.className = "city-card";

      const cityLabel = item.cidade || "";
      const price = formatBRL(getPriceForCategory(currentCategory));
      const badge = `<span class="pill ok">Disponível</span>`;
      const pricePill = `<span class="pill muted">${price}</span>`;

      const owns = userOwns(currentCategory, cityLabel);

      div.innerHTML = `
        <h4>${cityLabel}<small>Material digital com indicações selecionadas</small></h4>
        <div class="city-meta">${badge} ${pricePill}</div>
        <div class="city-actions">
          <button class="btn-ghost" data-add ${owns ? "disabled" : ""}>Adicionar ao carrinho</button>
          <button data-buy ${owns ? "disabled" : ""}>Comprar</button>
        </div>
      `;

      div.querySelector("[data-add]").addEventListener("click", async () => {
        /* se estiver deslogado, não sabemos se possui -> seguimos fluxo normal
           se estiver logado, ownedMap já está carregado e o botão estará desabilitado */
        addToCart(currentCategory, cityLabel);
        if (!userOwns(currentCategory, cityLabel)){
          openPopup({
            title: "Carrinho",
            text: "Material adicionado ao carrinho.",
            showProsseguir: false,
            showRules: false
          });
        }
      });

      div.querySelector("[data-buy]").addEventListener("click", () => openDestinationPopup(currentCategory, cityLabel));

      grid.appendChild(div);
    });

    if (btnMore){
      btnMore.style.display = visibleCount < total ? "inline-flex" : "none";
    }
  }

  /* =========================
     Popup do DESTINO (impedir recomprar)
  ========================= */
  function openDestinationPopup(category, city){
    const msg =
      `${category} é um material digital com indicações e referências selecionadas para apoiar suas decisões de viagem. ` +
      `Este conteúdo é liberado após a confirmação da compra.`;

    const owns = userOwns(category, city);

    if (owns){
      openPopup({
        title: city,
        text: "Você já possui este produto. Ele já está disponível em Minha conta.",
        showProsseguir: false,
        showRules: false,
        secondaryText: "Minha conta",
        onSecondary: () => {
          goAccount();
        }
      });
      return;
    }

    openPopup({
      title: city,
      text: msg,
      showProsseguir: true,
      prosseguirText: "Ir para pagamento",
      showRules: true,
      requireConsent: true,
      secondaryText: "Continuar comprando",
      onSecondary: () => {
        addToCart(category, city);
        if (!userOwns(category, city)){
          openPopup({
            title: "Carrinho",
            text: "Material adicionado ao carrinho.",
            showProsseguir: false,
            showRules: false
          });
        }
      },
      onProsseguir: async () => {
        await startSingleCheckoutAfterPolicy(category, city);
      }
    });
  }

  /* =========================
     Retomar após login
  ========================= */
  async function resumeAfterLoginIfNeeded(){
    const flag = getQueryParam("after_login");
    if (flag !== "1") return;

    try{
      const u = new URL(window.location.href);
      u.searchParams.delete("after_login");
      window.history.replaceState({}, "", u.toString());
    }catch(e){}

    const ctx = getCheckoutContext();
    if (!ctx || !ctx.type) return;

    const sess = await getSession();
    if (!sess || !sess.user) return;

    clearCheckoutContext();

    if (ctx.type === "single" && ctx.category && ctx.city){
      await loadOwnedPurchases();
      if (userOwns(ctx.category, ctx.city)){
        openPopup({
          title: ctx.city,
          text: "Você já possui este produto. Ele já está disponível em Minha conta.",
          showProsseguir: false,
          showRules: false
        });
        return;
      }
      goInvoiceSingle(ctx.category, ctx.city);
      return;
    }

    if (ctx.type === "cart"){
      await startCartCheckoutFlow();
      return;
    }
  }

  /* =========================
     INIT
  ========================= */
  document.addEventListener("DOMContentLoaded", async () => {
    ensureSupabase();
    updateCartBadge();
    updateFooterVisibility();
    await refreshNavAuth();
    await loadActiveMaterials();
    await loadOwnedPurchases();
    await handleCartAfterPurchaseIfNeeded();
    await resumeAfterLoginIfNeeded();
  });
</script>

</body>
</html>
